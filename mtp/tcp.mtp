/**************  event declarations ***************/

event LISTEN: INCOMING::APP_EVENT{
    uinr32 ip_addr;
    uint16 port;
}

event SEND : INCOMING::APP_EVENT {
    uint32 data_size;
}

event SYN : INCOMING::NET_EVENT {
    uint32 remote_ip;
    uint16 remote_port;
    uint32 init_seq;
    uint16 rwnd_size;
}

event ACK : INCOMING::NET_EVENT {
    uint32 ack_seq;
    uint32 rwnd_size;
}

event DATA : INCOMING::NET_EVENT {
    uint32 data_len;
    uint32 seq_num;
    addr_t hold_addr;
}

event MISS_ACK : TIMER_EVENT {
    uint32 seq_num;
}


/**************  TCP packet blueprint  ***************/

pkt_bp TCPBP {
    uint16 src_port;
    uint16 dest_port;
    uint32 seq;
    uint32 ack_seq;
    uint4  data_offset;
    uint4  reserved;
    bool   is_cwr;
    bool   is_ece;
    bool   is_urg;
    bool   is_ack;
    bool   push;
    bool   rst;
    bool   is_syn;
    bool   is_fin;
    uint16 rwnd_size;
    checksum16_t checksum;
    uint6  urg_ptr;
    data_t data;
}

/****************** contexts and other structs **************/
context tcp_listen_context{
    uint32 local_ip;
    uint32 local_port;
}

context tcp_context {
    uint32 remote_ip;
    uint32 local_ip;
    uint16 remote_port;
    uint16 local_port;
    addr_t buf_addr;

    // sender vars
    uint32 init_seq;
    uint32 last_ack = 429496729;
    uint8 duplicate_acks = 0;
    uint32 flightsize_dupl = 0;
    uint32 ssthresh = 0;
    uint32 cwnd_size = 3 * SMSS;

    uint32 RTO = ONE_SEC;
    int64 SRTT = 0;
    uint32 RTTVAR = 0;
    bool first_rto = 1;

    uint32 send_una = 0;
    uint32 send_next = 0;
    uint32 data_end = 0;
    uint32 last_rwnd_size = 16959;

    // receiver vars
    uint32 recv_init_seq;
    uint32 rwnd_size = 16959;
    //uint32 snd_wl1;		// segment seq number for last window update
	//uint32 snd_wl2;		// segment ack number for last window update
    uint32 recv_next = 0;
    //list<sent_pkt_info> data_recv_info_array(500);
    //uint32 data_recv_array_head = 0;
    //uint32 data_recv_array_tail = 0;

    timer_t ack_timeout;

    addr_t read_from_addr;
    addr_t write_to_addr;

    sliding_wnd meta_rwnd;
    buffer_id_t bid;
}

interm_output interm_out {
    bool change_cwnd;
    bool skip_ack_eps;
}

/****************** extracting events out of packets ********************/
net_to_transp ntt_module {
    net_header IPheader {
    	bool ecn;
        bit<16> identification;
        bit<3> flags;
        bit<8> ttl;
        bit<8> protocol;
        bit<16> hdrChecksum;
        uint16 tot_len;
        addr_t src_addr;
        addr_t dst_addr;
    }

    list<event_t> parse_net_packet(pkt_t p, IPheader i) { 
        list<event_t> out;
        TCPBP pkt_bp;
        p.extract(pkt_bp); 
        if (pkt_bp.is_syn && !pkt_bp.is_ack){
           flow_id id(i.dst_addr, pkt_bp.dest_port);
           SYN event;
           event.remote_ip = i.src_ip;
           event.remote_port = pkt_bp.src_port;
           event.init_seq = pkt_bp.seq;
           event.rwnd_size = pkt_bp.rwnd_size;
           out.add(event);
           return out;
        }
        flow_id id(i.src_addr, i.dst_addr, p.src_port, p.dest_port);
        if(len(pkt_bp.data) > 0) {
            DATA event;
            event.seq_num = pkt_bp.seq;
            event.hold_addr = pkt_bp.data.addr;
            event.data_len = len(pkt_bp.data);
            set_flow_id(event, id);
            out.add(event);
        }
        if(pkt_bp.is_ack == 1) {
            ACK event;
            event.ack_seq = pkt_bp.ack_seq;
            event.rwnd_size = pkt_bp.rwnd_size;
            set_flow_id(event, id);
            out.add(ack_ev);
        }
        return out;
    }
}

/************************ event processor declarations **************************/
list<instr_t> send_ep (SEND ev, tcp_context ctx, interm_out int_out);

list<instr_t> syn_ep (SYN ev, tcp_listen_context ctx, interm_out int_out);

void rto_ep (ACK ev, tcp_context ctx, interm_out int_out);
void fast_retr_rec_ep (ACK ev, tcp_context ctx, interm_out int_out);
void slows_congc_ep (ACK ev, tcp_context ctx, interm_out int_out);
list<instr_t> ack_net_ep (ACK ev, tcp_context ctx, interm_out int_out);

void data_net_ep (DATA ev, tcp_context ctx, interm_out int_out);
list<instr_t> send_ack (DATA ev, tcp_context ctx, interm_out int_out);
list<intr_t> app_feedback_ep (DATA ev, tcp_context ctx, interm_out int_out);

list<instr_t> ack_timeout_ep (MISS_ACK ev, tcp_context ctx, interm_out int_out);

/*************************** dispatcher ************************/
dispatch disp_table {
    SEND      -> {send_ep};
    SYN       -> {syn_ep};
    ACK       -> {rto_ep, fast_retr_rec_ep, slows_congc_ep, ack_net_ep};
    DATA      -> {data_net_ep, send_ack, app_feedback_ep};
    MISS_ACK   -> {ack_timeout_ep};
}

/************************* event processor definitions ****************************/

list<instr_t> send_ep (SEND ev, tcp_context ctx, interm_out int_out) {
    list<instr_t> out;

    uint32 SMSS = 1460;

    ctx.data_end = ctx.data_end + ev.data_size;

    uint32 data_rest = ctx.data_end - ctx.send_next;
    uint32 effective_window = ctx.cwnd_size;
    if(effective_window > ctx.last_rwnd_size)
        effective_window = ctx.last_rwnd_size;

    uint32 bytes_to_send = 0;

    if(ctx.send_una + effective_window < ctx.send_next)
        return;
    else {
        uint32 window_avail = 0;
        if (ctx.send_una + effective_window > ctx.send_next)
            window_avail = ctx.send_una + effective_window - ctx.send_next;
        
        if(data_rest < window_avail)
            bytes_to_send = data_rest;
        else
            bytes_to_send = window_avail;
    }

    TCPBP bp;
    bp.src_port = ctx.src_port;
    bp.dest_port = ctx.dest_port;
    bp.seq_num = ctx.send_next;
    bp.is_ack = 0;
    // bp.checksum = CRC16_t();
    addr_t addr = ctx.buf_addr + ctx.send_next - ctx.init_seq;
    bp.data = unseg_data(addr, bytes_to_send, SMSS, TCPBP::seq_num, len(TCPBP::data));

    instr_t instr = pkt_gen_instr(ctx.local_ip, ctx.remote_ip, bp);
    out.add(instr);

    ctx.send_next = ctx.send_next + bytes_to_send;

    MISS_ACK time_ev;
    time_ev.seq_num = ctx.send_una;
    ctx.ack_timeout.set_duration(nanosecond(ctx.RTO));
    ctx.ack_timeout.start(time_ev);

    return out;
}


list<instr_t> syn_ep (SYN ev, tcp_listen_context ctx, interm_out int_out) {
    list<instr_t> out;
    uint32 init_seq = rand();
    instr_t instr = new_ctx_instr(tcp_context, 
                                  remote_ip = ev.remote_ip, 
                                  local_ip = ctx.local_ip,
                                  remote_port = ev.remote_port,
                                  local_port = ctx.local_port,
                                  init_seq = init_seq,
                                  send_next = init_seq + 1,
                                  recv_init_seq = ev.init_seq,
                                  recv_next = ev.init_seq + 1,
                                  last_rwnd_size = ev.rwnd_size);

     
    out.add(instr);

    TCBBP bp;
    bp.src_port = ctx.local_port;
    bp.dst_port = ctx.remote_port;
    bp.is_syn = true;
    bp.is_ack = true;
    bp.ack_seq = ev.init_seq + 1;
    bp.seq = init_seq;
    instr_t instr = pkt_gen_instr(local_ip, remote_ip, bp);
    out.add(instr);

    return out;
}

void rto_ep (ACK ev, tcp_context ctx, interm_out int_out) {

    int_out.skip_ack_eps = 0;

    if(ev.ack_seq < ctx.send_una || ctx.send_next < ev.ack_seq) {
        int_out.skip_ack_eps = 1;
        return;
    }

    uint32 granularity_g = 1;
    uint32 RTT = 100000000;

    if(ctx.first_rto) {
        ctx.SRTT = RTT;
        ctx.RTTVAR = RTT / 2;
        if(granularity_g >= 4 * ctx.RTTVAR)
            ctx.RTO = ctx.SRTT + granularity_g;
        else
            ctx.RTO = ctx.SRTT + 4 * ctx.RTTVAR;
        
        ctx.first_rto = false;
    } else {
        ctx.RTTVAR = (1 - 1/4) * ctx.RTTVAR + 1/4 * abs(ctx.SRTT - RTT);
        ctx.SRTT = (1 - 1/8) * ctx.SRTT + 1/8 * RTT;
        if(granularity_g >= 4 * ctx.RTTVAR)
            ctx.RTO = ctx.SRTT + granularity_g;
        else
            ctx.RTO = ctx.SRTT + 4 * ctx.RTTVAR;
    }
}

void fast_retr_rec_ep (ACK ev, tcp_context ctx, interm_out int_out) {

    if(int_out.skip_ack_eps)
        return;
    
    uint32 SMSS = 1460;

    int_out.change_cwnd = 1;

    if(ev.ack_seq == ctx.last_ack) {
        ctx.duplicate_acks = ctx.duplicate_acks + 1;

        int_out.change_cwnd = 0;

        if(ctx.duplicate_acks == 1) {
            ctx.flightsize_dupl = ctx.send_next - ctx.send_una;
        }

        if(ctx.duplicate_acks == 3) {

            uint32 opt1 = ctx.flightsize_dupl / 2;
            uint32 opt2 = 2 * SMSS;
            if(opt1 >= opt2)
                ctx.ssthresh = opt1;
            else
                ctx.ssthresh = opt2;

            ctx.cwnd_size = ctx.ssthresh + 1 * SMSS;
        }
        
        if(ctx.duplicate_acks != 3) {
            ctx.cwnd_size = ctx.cwnd_size + SMSS;
        }

    } else {
        if(ctx.duplicate_acks > 0) {
            ctx.cwnd_size = ctx.ssthresh;
        }

        ctx.duplicate_acks = 0;
        ctx.last_ack = ev.ack_seq;
    }
}

void slows_congc_ep (ACK ev, tcp_context ctx, interm_out int_out) {

    if(int_out.skip_ack_eps)
        return;

    uint32 SMSS = 1460;
    uint32 EFF_SMSS = 1448;     // SMSS - TCP options (timestamp + alignment)

    if(int_out.change_cwnd) {
        // calculate how many packets have been acked
        uint32 rmlen = ev.ack_seq - ctx.send_una;
        uint16 packets = rmlen / EFF_SMSS;
        if (packets * EFF_SMSS > rmlen) {
            packets = packets + 1;
        }

        if(ctx.cwnd_size < ctx.ssthresh) {
            ctx.cwnd_size = ctx.cwnd_size + SMSS * packets;
        }
        else {
            uint32 add_cwnd = packets * SMSS * SMSS / ctx.cwnd_size;
            ctx.cwnd_size = ctx.cwnd_size + add_cwnd;
        }
    }
}

list<instr_t> ack_net_ep (ACK ev, tcp_context ctx, interm_out int_out) {
    list<instr_t> out;

    uint32 SMSS = 1460;

    if(int_out.skip_ack_eps)
        return out;

    // Update window, and allow user to start writing 
    // if peer just has space to receive packets
    ctx.last_rwnd_size = ctx.rwnd_size;
    ctx.rwnd_size = ev.rwnd_size;
    if (ctx.last_rwnd_size < ctx.send_next - ctx.send_una &&
        ctx.rwnd_size >= ctx.send_next - ctx.send_una) {
        intr_t instr = notify_app();
        out.add(instr);
    }

    uint32 data_rest = ctx.data_end - ctx.send_next;
    if(data_rest == 0 && ev.ack_seq == ctx.send_next) {
        ctx.ack_timeout.cancel();
        return out;
    }

    uint32 effective_window = ctx.cwnd_size;
    if(effective_window > ctx.last_rwnd_size)
        effective_window = ctx.last_rwnd_size;

    uint32 bytes_to_send = 0;

    if(ctx.duplicate_acks == 3) {
        bytes_to_send = SMSS;
        if(bytes_to_send > effective_window)
            bytes_to_send = effective_window;

        TCPBP bp;
        bp.src_port = ctx.src_port;
        bp.dest_port = ctx.dest_port;
        bp.seq_num = ctx.send_una;
        bp.is_ack = 0;
        // bp.checksum = CRC16_t();
        addr_t addr = ctx.buf_addr + ctx.send_una - ctx.init_seq;
        bp.data = seg_data(addr, bytes_to_send);

        instr_t instr = pkt_gen_instr(ctx.local_ip, ctx.remote_ip, bp);
        out.add(instr);

        return out;
    }

    uint32 window_avail = 0;
    if (ctx.send_una + effective_window > ctx.send_next)
        window_avail = ctx.send_una + effective_window - ctx.send_next;

    if(window_avail == 0)
        bytes_to_send = 0;
    else {
        if(data_rest < window_avail) {
            bytes_to_send = data_rest;
        } else {
            if (window_avail < data_rest)
                bytes_to_send = window_avail;
            else
                bytes_to_send = data_rest;
        }
    }

    TCPBP bp;
    bp.src_port = ctx.src_port;
    bp.dest_port = ctx.dest_port;
    bp.seq_num = ctx.send_next;
    bp.is_ack = 0;
    // bp.checksum = CRC16_t();
    addr_t addr = ctx.buf_addr + ctx.send_next - ctx.init_seq;
    // Q: in case there are more than one header value that needs to change (e.g. PSN and opcode), can we keep adding parameters?
    // A: Rocev2PBP::opcode, [6, 7..., 8] or (6. 7*. 8) | 9
    // p1 = patten([6, 7..., 8]);
    // p2 = patten(9);
    // p1 | p2
    seg_args plan1 {
        TCPBP::seq_num -> len(TCPBP::data);
        TCPBP::opcode -> [6, 7..., 8];
    }
    bp.data = unseg_data(addr, bytes_to_send, SMSS, plan1);

    instr_t instr = pkt_gen_instr(ctx.local_ip, ctx.remote_ip, bp);
    out.add(instr);

    ctx.send_next = ctx.send_next + bytes_to_send;

    // Remove acked data from sending buffer
    // The implementation of sending buffer is more target dependent
    uint32 rmlen = ev.ack_seq - ctx.send_una;
    if (rmlen > 0) {
        ctx.buf_addr = ctx.buf_addr + rmlen;
        ctx.send_una = ev.ack_seq;
    }

    ctx.ack_timeout.cancel();
    MISS_ACK time_ev;
    time_ev.seq_num = ctx.send_una;
    ctx.ack_timeout.set_duration(nanosecond(ctx.RTO));
    ctx.ack_timeout.start(time_ev);

    return out;
}

void data_net_ep (DATA ev, tcp_context ctx, interm_out int_out) {

    if((ctx.rwnd_size == 0 && ev.data_len > 0) ||
    (ev.seq_num > ctx.recv_next + ctx.rwnd_size) ||
    (ev.seq_num + ev.data_len - 1 < ctx.recv_next))
        return;

    uint32 data_end = ev.seq_num + ev.data_len;
    ctx.meta_rwnd.set(ev.seq_num, data_end);
    ctx.recv_next = ctx.meta_rwnd.first_unset();
}

list<instr_t> send_ack (DATA ev, tcp_context ctx, interm_out int_out) {
    list<instr_t> out;

    uint32 SMSS = 1460;

    uint32 data_rest = ctx.data_end - ctx.send_next;
    uint32 effective_window = ctx.cwnd_size;
    if(effective_window > ctx.last_rwnd_size)
        effective_window = ctx.last_rwnd_size;

    uint32 window_avail = ctx.send_una + effective_window - ctx.send_next;
    uint32 bytes_to_send = 0;

    if(window_avail < 0)
        bytes_to_send = 0;
    else {
        if(data_rest < window_avail)
            bytes_to_send = data_rest;
        else
            bytes_to_send = window_avail;
        
        if(bytes_to_send > SMSS)
            bytes_to_send = SMSS;
    }

    TCPBP bp;
    bp.src_port = ctx.src_port;
    bp.dest_port = ctx.dest_port;
    bp.seq_num = ctx.send_next;
    bp.is_ack = 1;
    bp.ack_seq = ctx.recv_next;
    bp.wnd_size = ctx.rwnd_size;
    // bp.checksum = CRC16_t();
    addr_t addr = ctx.buf_addr + ctx.send_next - ctx.init_seq;
    // Q: in case no payload is sent, what should the address be?
    // A: have something special for NULL data
    bp.data = seg_data(addr, bytes_to_send);

    instr_t instr = pkt_gen_instr(ctx.local_ip, ctx.remote_ip, bp);
    out.add(instr);

    return out;
}

list<intr_t> app_feedback_ep (DATA ev, tcp_context ctx, interm_out int_out) {
    list<intr_t> out;

    DATA_EVENT ev;
    ev.read_addr = ev.hold_addr;
    ev.size = ev.data_len;
    ev.buffer_id = ctx.bid;
    ev.offset = ev.seq_num - ctx.init_seq;

    instr_t instr = flush_and_notify_app();
    out.add(instr);

    return out;
}

list<instr_t> ack_timeout_ep (MISS_ACK ev, tcp_context ctx, interm_out int_out) {
    list<instr_t> out;

    uint32 SMSS = 1460;

    ctx.cwnd_size = SMSS * 3;
    uint32 opt1 = (ctx.send_next - ctx.send_una) / 2;
    uint32 opt2 = 2 * SMSS;
    if(opt1 > opt2)
        ctx.ssthresh = opt1;
    else
        ctx.ssthresh = opt2;
    
    uint32 data_rest = ctx.data_end - ctx.send_una;
    uint32 effective_window = ctx.cwnd_size;
    if(effective_window > ctx.last_rwnd_size)
        effective_window = ctx.last_rwnd_size;
    
    uint32 bytes_to_send = 0;

    if(ctx.send_una + effective_window < ctx.send_next) {
        if(data_rest < effective_window)
            bytes_to_send = data_rest;
        else
            bytes_to_send = effective_window;
    } else {
        uint32 window_avail = ctx.send_una + effective_window - ctx.send_next;
        if(data_rest < window_avail)
            bytes_to_send = data_rest;
        else
            bytes_to_send = window_avail;
    }
    if(bytes_to_send > SMSS)
        bytes_to_send = SMSS;

    TCPBP bp;
    bp.src_port = ctx.src_port;
    bp.dest_port = ctx.dest_port;
    bp.seq_num = ctx.send_next;
    bp.is_ack = 0;
    bp.wnd_size = ctx.rwnd_size;
    // bp.checksum = CRC16_t();
    addr_t addr = ctx.buf_addr + ctx.send_una - ctx.init_seq;
    bp.data = seg_data(addr, bytes_to_send);

    instr_t instr = pkt_gen_instr(ctx.local_ip, ctx.remote_ip, bp);
    out.add(instr);

    ctx.ack_timeout.restart(nanosecond(ctx.RTO));
}


