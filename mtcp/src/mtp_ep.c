#include "mtp_ep.h"

#include <linux/tcp.h>

#include "tcp_in.h"
#include "tcp_out.h"
#include "timer.h"
#include "tcp_stream.h"
#include "fhash.h"
#include "debug.h"
#include "ip_out.h"
#include "tcp_util.h"
#include "socket.h"
#include "mtp_instr.h"
#include "mtp_net.h"
#include "mtp_seq.h"

#define MAX(a, b) ((a)>(b)?(a):(b))
#define MIN(a, b) ((a)<(b)?(a):(b))
#define TCP_MAX_WINDOW 65535

// Intermediate output
typedef struct scratchpad_decl {
	uint8_t change_cwnd;
	bool skip_ack_eps;
} scratchpad;


// Helper functions
/*----------------------------------------------------------------------------*/
static inline void EstimateRTT(mtcp_manager_t mtcp, tcp_stream *cur_stream, uint32_t mrtt)
{
	/* This function should be called for not retransmitted packets */
	/* TODO: determine tcp_rto_min */
#define TCP_RTO_MIN 0
	long m = mrtt;
	uint32_t tcp_rto_min = TCP_RTO_MIN;
	struct tcp_recv_vars *rcvvar = cur_stream->rcvvar;

	if (m == 0) {
		m = 1;
	}
	if (rcvvar->srtt != 0) {
		/* rtt = 7/8 rtt + 1/8 new */
		m -= (rcvvar->srtt >> 3);
		rcvvar->srtt += m;
		if (m < 0) {
			m = -m;
			m -= (rcvvar->mdev >> 2);
			if (m > 0) {
				m >>= 3;
			}
		} else {
			m -= (rcvvar->mdev >> 2);
		}
		rcvvar->mdev += m;
		if (rcvvar->mdev > rcvvar->mdev_max) {
			rcvvar->mdev_max = rcvvar->mdev;
			if (rcvvar->mdev_max > rcvvar->rttvar) {
				rcvvar->rttvar = rcvvar->mdev_max;
			}
		}
		if (TCP_SEQ_GT(cur_stream->mtp->send_una, rcvvar->rtt_seq)) {
			if (rcvvar->mdev_max < rcvvar->rttvar) {
				rcvvar->rttvar -= (rcvvar->rttvar - rcvvar->mdev_max) >> 2;
			}
			rcvvar->rtt_seq = cur_stream->mtp->send_next;
			rcvvar->mdev_max = tcp_rto_min;
		}
	} else {
		/* fresh measurement */
		rcvvar->srtt = m << 3;
		rcvvar->mdev = m << 1;
		rcvvar->mdev_max = rcvvar->rttvar = MAX(rcvvar->mdev, tcp_rto_min);
		rcvvar->rtt_seq = cur_stream->mtp->send_next;
	}

	TRACE_RTT("mrtt: %u (%uus), srtt: %u (%ums), mdev: %u, mdev_max: %u, "
			"rttvar: %u, rtt_seq: %u\n", mrtt, mrtt * TIME_TICK, 
			rcvvar->srtt, TS_TO_MSEC((rcvvar->srtt) >> 3), rcvvar->mdev, 
			rcvvar->mdev_max, rcvvar->rttvar, rcvvar->rtt_seq);
}


/***********************************************
 MTP Event Processors
 
 EPs are static and used only by MTP EP chains
 They have 1-to-1 mappings to mtp code
 They should be generated by the MTP compiler
 ***********************************************/
static inline void send_ep(mtcp_manager_t mtcp, uint32_t cur_ts, tcp_stream *cur_stream)
{
	struct tcp_send_vars *sndvar = cur_stream->sndvar;

    if (cur_stream->mtp->state != MTP_TCP_ESTABLISHED_ST) return;

	struct mtp_ctx *ctx = cur_stream->mtp;
	
	// printf("send_ep before grabbing lock\n");
	SBUF_LOCK(&sndvar->write_lock);
	// printf("send_ep after grabbing lock\n");

	// printf("in send ep\n");
	if (!sndvar->sndbuf || sndvar->sndbuf->len == 0) {
        SBUF_UNLOCK(&sndvar->write_lock);
        return;
	}

	// MTP: maps to bytes_to_send
	int data_rest = sndvar->sndbuf->len - 
					MTP_SEQ_SUB(ctx->send_next, sndvar->sndbuf->head_seq, 
								sndvar->sndbuf->head_seq);
	int window_avail = MIN(ctx->cwnd_size, ctx->last_rwnd_remote) - 
					   MTP_SEQ_SUB(ctx->send_next, ctx->send_una, ctx->send_una);

    int bytes_to_send = MIN(data_rest, window_avail);

	// printf("send_ep bytes to send: %d, data_rest: %d, window_avail: %d\n", 
	// 		bytes_to_send, data_rest, window_avail);

	if (bytes_to_send <= 0) {
		// printf("send_ep before releasing lock\n");
		SBUF_UNLOCK(&sndvar->write_lock);
		// printf("send_ep after releasing lock\n");
        return;
	}

	// printf("send_ep bytes to send: %d\n", bytes_to_send);
	// MTP: maps to packet blueprint creation
	
	mtp_bp* bp = GetFreeBP(cur_stream);
	// printf("got bp\n");
	// printf("index: %u\n", cur_stream->sndvar->mtp_bps_tail);
    
    memset(&(bp->hdr), 0, sizeof(struct mtp_bp_hdr) + sizeof(struct mtp_bp_options));

    bp->hdr.source = cur_stream->mtp->local_port;
    bp->hdr.dest = cur_stream->mtp->remote_port;
    bp->hdr.seq = htonl(ctx->send_next);
	// printf("Seq in send_ep: %u\n", ntohl(bp->hdr.seq));
    bp->hdr.ack_seq = htonl(ctx->recv_next);

    bp->hdr.syn = FALSE;
    bp->hdr.ack = TRUE;

    // options to calculate data offset
   
    // MTP TODO: SACK? 
#if TCP_OPT_SACK_ENABLED
    printf("ERROR:SACK Not supported in MTP TCP\n");
#endif

    MTP_set_opt_nop(&(bp->opts.nop1));
    MTP_set_opt_nop(&(bp->opts.nop2));

    // MTP TODO: Timestamp
    MTP_set_opt_timestamp(&(bp->opts.timestamp),
                            htonl(cur_ts),
                            htonl(ctx->ts_recent));
    
   
    // MTP TODO: would the MTP program do the length 
    //           calculation itself?
    uint16_t optlen = MTP_CalculateOptionLength(bp);
    bp->hdr.doff = (MTP_HEADER_LEN + optlen) >> 2;

    // MTP TODO: wscale on local
	uint8_t wscale = ctx->wscale;
    uint32_t window32 = ctx->rwnd_size >> wscale;  
	// MTP TODO: fix this
    uint16_t advertised_window = (uint16_t)MIN(window32, TCP_MAX_WINDOW);
    bp->hdr.window = htons(advertised_window);

    // Payload
    // MTP TODO: fix snbuf
    uint8_t *data = sndvar->sndbuf->head + MTP_SEQ_SUB(ctx->send_next,
													   sndvar->sndbuf->head_seq,
													   sndvar->sndbuf->head_seq);
    bp->payload.data = data;
    bp->payload.len = bytes_to_send;
	if (bytes_to_send > ctx->eff_SMSS){
		bp->payload.needs_segmentation = TRUE;
		bp->payload.seg_size = ctx->eff_SMSS;
		bp->payload.seg_rule_group_id = 1; 
	}

    AddtoGenList(mtcp, cur_stream, cur_ts);	

	// printf("prepared bp:\n");
	// print_MTP_bp(bp);
	// printf("head ptr: %p, head seq: %d, len: %d\n", sndvar->sndbuf->head, 
	// 		sndvar->sndbuf->head_seq, sndvar->sndbuf->len);

	// MTP TODO: implement + for MTP_SEQ
	ctx->send_next += bytes_to_send;

	// printf("send next: %u\n", ctx->send_next);

	// MTP TODO: map to timer event with event input
	TimerStart(mtcp, cur_stream, cur_ts);

	// printf("send_ep before releasing lock\n");
	SBUF_UNLOCK(&sndvar->write_lock);
	// printf("send_ep after releasing lock\n");
	return;
}

static inline int receive_ep(mtcp_manager_t mtcp, socket_map_t socket, 
								char *ev_buf, int ev_data_size, 
								tcp_stream *cur_stream)
{
	struct mtp_ctx* ctx = cur_stream->mtp;

	uint32_t data_avail = ctx->recv_next - 1 - ctx->last_flushed;
    if (data_avail > ev_data_size){
        data_avail = ev_data_size;
    }

	int ret = FlushAndNotify(mtcp, socket, cur_stream, ev_buf, data_avail);
    
    ctx->last_flushed += data_avail;
	ctx->rwnd_size = cur_stream->rcvvar->rcvbuf->size - MTP_SEQ_SUB(ctx->last_flushed, 
														ctx->recv_next, 
														ctx->recv_next);
	
	// MTP TODO: I think this has race conditions
	
	if (socket->epoll & MTCP_EPOLLIN) {
		if (!(socket->epoll & MTCP_EPOLLET) && ctx->recv_next > ctx->last_flushed + 1) {
			if (socket->epoll) {
				AddEpollEvent(mtcp->ep, USR_SHADOW_EVENT_QUEUE, socket, MTCP_EPOLLIN);
			}
		}
	}

	return ret;
	// TODO: send ack when window becomes non zero after being zero (part 2)
}

static inline void timestamp_ep(mtcp_manager_t mtcp, uint32_t cur_ts, 
		struct tcp_opt_timestamp* ev_ts, tcp_stream* cur_stream, scratchpad* scratch)
{
	struct mtp_ctx *ctx = cur_stream->mtp;
	
	if (ev_ts->valid) {
		// MTP TODO: do we need MTP_SEQ_LT here?
		if (ev_ts->value1 < ctx->ts_recent) {
			/* TODO: ts_recent should be invalidated 
					 before timestamp wraparound for long idle flow */
			printf("PAWS Detect wrong timestamp. "
					"ts_val: %u, prev: %u\n", 
					ev_ts->value1, ctx->ts_recent);
			// EnqueueACK(mtcp, cur_stream, cur_ts, ACK_OPT_NOW);
			return;
		} else {
			/* valid timestamp */
			if (ev_ts->value1 > ctx->ts_recent) {
				TRACE_TSTAMP("Timestamp update. cur: %u, prior: %u "
					"(time diff: %uus)\n", 
					ev_ts->value1, ctx->ts_recent, 
					TS_TO_USEC(cur_ts - ctx->ts_last_ts_upd));
				ctx->ts_last_ts_upd = cur_ts;
			}

			ctx->ts_recent = ev_ts->value1;
			ctx->ts_lastack_rcvd = ev_ts->value2;
			// MTP TODO: integrate with MTP
			cur_stream->rcvvar->ts_lastack_rcvd = ev_ts->value2;
		}
	}
	else {
		printf("timestamp_ep: no valid timestamp\n");
	}
}
static inline void conn_ack_ep ( mtcp_manager_t mtcp, int32_t cur_ts, uint32_t ev_ack_seq, 
        uint32_t ev_seq, tcp_stream* cur_stream, scratchpad* scratch){

	// printf("----------------------------- Ack: %u\n", ev_ack_seq);

	struct mtp_ctx *ctx = cur_stream->mtp;

    if (ctx->state == MTP_TCP_SYNACK_SENT_ST &&
        ev_ack_seq == ctx->init_seq + 1){
        ctx->state = MTP_TCP_ESTABLISHED_ST;
        ctx->send_una += 1;
        ctx->send_next = ev_ack_seq;
        ctx->last_ack = ev_ack_seq;

        if (ctx->cwnd_size == 1){
            ctx->cwnd_size = 2 * ctx->SMSS;
        }
        else {
            ctx->cwnd_size = ctx->SMSS;
        }

		ctx->lwu_seq = ev_seq;
		ctx->lwu_ack = ev_ack_seq;
        scratch->skip_ack_eps = TRUE;
		// MTP TODO: timer
        TimerCancel(mtcp, cur_stream);

        // MTP TODO: Raise an event to the listening socket
		struct mtp_listen_ctx *listen_ctx = 
			(struct mtp_listen_ctx *)ListenerHTSearch(mtcp->listeners, &cur_stream->sport);
		if (listen_ctx->socket && (listen_ctx->socket->epoll & MTCP_EPOLLIN)) {
			AddEpollEvent(mtcp->ep, MTCP_EVENT_QUEUE, listen_ctx->socket, MTCP_EPOLLIN);
		}
    }
    else {
        scratch->skip_ack_eps = FALSE;
		// printf("conn_ack, no skip: lwu_seq: %u, lwu_ack: %u, rwindow: %u\n", cur_stream->mtp->lwu_seq,
		// 							   cur_stream->mtp->lwu_ack,
		// 							   cur_stream->mtp->last_rwnd_remote);
    }

	
}

static inline void rto_ep( mtcp_manager_t mtcp, int32_t cur_ts, uint32_t ev_ack_seq, 
    tcp_stream* cur_stream, scratchpad* scratch)
{
    if (scratch->skip_ack_eps) return;

	// if (cur_stream->mtp->state != MTP_TCP_ESTABLISHED_ST) return;

    struct mtp_ctx* ctx = cur_stream->mtp;
	if (ctx->state == MTP_TCP_FIN_WAIT_1_ST || 
		ctx->state == MTP_TCP_FIN_WAIT_2_ST ||
		ctx->state == MTP_TCP_CLOSING_ST || 
		ctx->state == MTP_TCP_CLOSE_WAIT_ST || 
		ctx->state == MTP_TCP_LAST_ACK_ST) {
		if (ctx->fin_sent && ev_ack_seq == ctx->final_seq + 1) {
			ev_ack_seq--;
		}
	}
	
    if(MTP_SEQ_LT(ev_ack_seq, ctx->send_una, ctx->send_una) || 
	   MTP_SEQ_LT(ctx->send_next, ev_ack_seq, ctx->send_una)) {
		scratch->skip_ack_eps = TRUE;
		return;
	}
    
	// MTP TODO: make consistent with MTP
    // Set RTO, using RTT calculation logic from mTCP
	struct tcp_send_vars *sndvar = cur_stream->sndvar;
	struct tcp_recv_vars *rcvvar = cur_stream->rcvvar;
    uint32_t rtt = cur_ts - rcvvar->ts_lastack_rcvd;
	EstimateRTT(mtcp, cur_stream, rtt);
	sndvar->rto = (rcvvar->srtt >> 3) + rcvvar->rttvar;
}

static inline void fast_retr_rec_ep(mtcp_manager_t mtcp, uint32_t cur_ts, 
								    uint32_t ev_ack_seq, tcp_stream* cur_stream, 
									scratchpad* scratch)
{
	if(scratch->skip_ack_eps) return;
	// if (cur_stream->mtp->state != MTP_TCP_ESTABLISHED_ST) return;

    struct mtp_ctx* ctx = cur_stream->mtp;
	if (ctx->state == MTP_TCP_FIN_WAIT_1_ST || 
		ctx->state == MTP_TCP_FIN_WAIT_2_ST ||
		ctx->state == MTP_TCP_CLOSING_ST || 
		ctx->state == MTP_TCP_CLOSE_WAIT_ST || 
		ctx->state == MTP_TCP_LAST_ACK_ST) {
		if (ctx->fin_sent && ev_ack_seq == ctx->final_seq + 1) {
			ev_ack_seq--;
		}
	}

	scratch->change_cwnd = 1;

	// printf("fast_retr BEFORE: cwnd:%u, ssthresh:%u\n", ctx->cwnd_size, ctx->ssthresh);
	if(ev_ack_seq == ctx->last_ack) {
		ctx->duplicate_acks = ctx->duplicate_acks + 1;

		scratch->change_cwnd = 0;

		if(ctx->duplicate_acks == 1) {
			ctx->flightsize_dupl = MTP_SEQ_SUB(ctx->send_next, 
											   ctx->send_una, 
											   ctx->send_una);
		}

		if(ctx->duplicate_acks == 3) {
			// MTP congestion window resize
            uint32_t opt1 = ctx->flightsize_dupl/2;
            uint32_t opt2 = 2 * ctx->SMSS;
            if (opt1 >= opt2) ctx->ssthresh = opt1;
            else ctx->ssthresh = opt2;
			
            ctx->cwnd_size = ctx->ssthresh + ctx->SMSS;
		}

		if(ctx->duplicate_acks != 3) {
			ctx->cwnd_size += ctx->SMSS;
		}
	} else {
		if(ctx->duplicate_acks >= 3) {
			ctx->cwnd_size = ctx->ssthresh;
		}
		ctx->duplicate_acks = 0;
		ctx->last_ack = ev_ack_seq;
	}
	// printf("fast_retr AFTER: cwnd:%u, ssthresh:%u\n", ctx->cwnd_size, ctx->ssthresh);
}

static inline void slows_congc_ep(mtcp_manager_t mtcp, uint32_t cur_ts, uint32_t ev_ack_seq, 
	tcp_stream* cur_stream, scratchpad* scratch)
{
	if(scratch->skip_ack_eps) return;
	// if (cur_stream->mtp->state != MTP_TCP_ESTABLISHED_ST) return;
    struct mtp_ctx *ctx = cur_stream->mtp;

	if (ctx->state == MTP_TCP_FIN_WAIT_1_ST || 
		ctx->state == MTP_TCP_FIN_WAIT_2_ST ||
		ctx->state == MTP_TCP_CLOSING_ST || 
		ctx->state == MTP_TCP_CLOSE_WAIT_ST || 
		ctx->state == MTP_TCP_LAST_ACK_ST) {
		if (ctx->fin_sent && ev_ack_seq == ctx->final_seq + 1) {
			ev_ack_seq--;
		}
	}

	// printf("before DIV\n");
	// printf("slows_cong BEFORE: cwnd:%u\n", ctx->cwnd_size);
	if(scratch->change_cwnd) {
		uint32_t rmlen = MTP_SEQ_SUB(ev_ack_seq, ctx->send_una, ctx->send_una);
		// printf("rmlen: %u, eff_SMSS: %u\n", rmlen, ctx->eff_SMSS);
		uint16_t packets = rmlen / ctx->eff_SMSS;
		// printf("after\n");
		if (packets * ctx->eff_SMSS > rmlen) {
			packets++;
		}

		if (ctx->cwnd_size < ctx->ssthresh) {
			ctx->cwnd_size += (ctx->SMSS * packets);
		} else {
			// printf("SMSS: %u, cwnd: %u\n", ctx->SMSS, ctx->cwnd_size);
			uint32_t add_cwnd = packets * ctx->SMSS * ctx->SMSS / ctx->cwnd_size;
			// printf("after\n");
			ctx->cwnd_size += add_cwnd;
		}
	}
	// printf("after DIV\n");
	// printf("slows_cong AFTER: cwnd:%u\n", ctx->cwnd_size);
}

static inline void ack_net_ep(mtcp_manager_t mtcp, uint32_t cur_ts, uint32_t ev_ack_seq, 
	uint32_t ev_window, uint32_t ev_seq, tcp_stream* cur_stream, scratchpad* scratch)
{
	// MTP TODO: do wscale properly?
	if(scratch->skip_ack_eps) return;

	struct mtp_ctx *ctx = cur_stream->mtp;
	
	if (ctx->state == MTP_TCP_FIN_WAIT_1_ST || 
		ctx->state == MTP_TCP_FIN_WAIT_2_ST ||
		ctx->state == MTP_TCP_CLOSING_ST || 
		ctx->state == MTP_TCP_CLOSE_WAIT_ST || 
		ctx->state == MTP_TCP_LAST_ACK_ST) {
		if (ctx->fin_sent && ev_ack_seq == ctx->final_seq + 1) {
			ev_ack_seq--;
		}
	}
	
	// if (cur_stream->mtp->state != MTP_TCP_ESTABLISHED_ST) return;


	struct tcp_send_vars *sndvar = cur_stream->sndvar;
	
	// printf("ack_net_ep before grabbing lock\n");
	SBUF_LOCK(&sndvar->write_lock);
	// printf("ack_net_ep after grabbing lock\n");

	// Update window
	// printf("ev_window: %u, wscale_remote: %u\n", ev_window, ctx->wscale_remote);
	uint32_t rwindow = ev_window << ctx->wscale_remote;
	// printf("rwindow: %u\n", rwindow);
    // MTP TODO: sequence comparisons
    if (MTP_SEQ_LT(ctx->lwu_seq, ev_seq, ctx->send_una) ||
        (ctx->lwu_seq == ev_seq && MTP_SEQ_LT(ctx->lwu_ack, ev_ack_seq, ctx->send_una)) ||
        (ctx->lwu_ack == ev_ack_seq && rwindow > ctx->last_rwnd_remote)){
        uint32_t rwindow_prev = ctx->last_rwnd_remote;
		// printf("ack_net_ep, before: lwu_seq: %u, lwu_ack: %u, rwindow: %u\n", cur_stream->mtp->lwu_seq,
		// 							   cur_stream->mtp->lwu_ack,
		// 							   cur_stream->mtp->last_rwnd_remote);
        ctx->last_rwnd_remote = rwindow;
        ctx->lwu_seq = ev_seq;
        ctx->lwu_ack = ev_ack_seq;
		// printf("ack_net_ep, after: lwu_seq: %u, lwu_ack: %u, rwindow: %u\n", cur_stream->mtp->lwu_seq,
		// 							   cur_stream->mtp->lwu_ack,
		// 							   cur_stream->mtp->last_rwnd_remote);
        if (rwindow_prev < MTP_SEQ_SUB(ctx->send_next, ctx->send_una, ctx->send_una) &&
            ctx->last_rwnd_remote >= MTP_SEQ_SUB(ctx->send_next, ctx->send_una, ctx->send_una)){
            // This is kinda "notify" in MTP
            RaiseWriteEvent(mtcp, cur_stream);
        }
    }
 
    // MTP TODO: fix sndbuf->len	
	uint32_t data_rest =  sndvar->sndbuf->len - 
					      MTP_SEQ_SUB(ctx->send_next, sndvar->sndbuf->head_seq,
									  sndvar->sndbuf->head_seq);

	// printf("ack_net_ep: data_rest: %d, ev_ack_seq: %u, send_next: %u, len: %d, head_seq:%d\n", 
	// 		data_rest, ev_ack_seq, ctx->send_next, sndvar->sndbuf->len, sndvar->sndbuf->head_seq);

	if (data_rest == 0 && ev_ack_seq == ctx->send_next) {
		TimerCancel(mtcp, cur_stream);
		printf("THIS CASE\n");
		// printf("ack_net_ep before releasing lock\n");
		SBUF_UNLOCK(&sndvar->write_lock);
		// printf("ack_net_ep after releasing lock\n");
		return;
	}

	uint32_t effective_window = ctx->cwnd_size;
    if (ctx->last_rwnd_remote < effective_window){
        effective_window = ctx->last_rwnd_remote;
    }
	
	// printf("ack_net_ep: cwnd: %d, rwnd: %d\n", ctx->cwnd_size, ctx->last_rwnd_remote);
    uint32_t bytes_to_send = 0;

	if(ctx->duplicate_acks == 3) {
		bytes_to_send = ctx->eff_SMSS;
        if (bytes_to_send > effective_window){
            bytes_to_send = effective_window;
        }

        // MTP TODO: check that size + options is not more than MSS
        mtp_bp* bp = GetFreeBP(cur_stream);
		// printf("dup ack got bp\n");
		// printf("index: %u\n", cur_stream->sndvar->mtp_bps_tail);
        
        memset(&(bp->hdr), 0, sizeof(struct mtp_bp_hdr) + sizeof(struct mtp_bp_options));

        bp->hdr.source = ctx->local_port;
        bp->hdr.dest = ctx->remote_port;
        bp->hdr.seq = htonl(ctx->send_una);
		// printf("dup ack Seq: %u\n", ntohl(bp->hdr.seq));
        bp->hdr.ack_seq = htonl(ctx->recv_next);

        bp->hdr.syn = FALSE;
        bp->hdr.ack = TRUE;

        // options to calculate data offset
       
        // MTP TODO: SACK? 
    #if TCP_OPT_SACK_ENABLED
        printf("ERROR:SACK Not supported in MTP TCP\n");
    #endif

        MTP_set_opt_nop(&(bp->opts.nop1));
        MTP_set_opt_nop(&(bp->opts.nop2));

        // MTP TODO: Timestamp
        MTP_set_opt_timestamp(&(bp->opts.timestamp),
                                htonl(cur_ts),
                                htonl(ctx->ts_recent));
        
       
        // MTP TODO: would the MTP program do the length 
        //           calculation itself?
        uint16_t optlen = MTP_CalculateOptionLength(bp);
        bp->hdr.doff = (MTP_HEADER_LEN + optlen) >> 2;

        // MTP TODO: wscale on local
        uint8_t wscale = ctx->wscale;
    	uint32_t window32 = ctx->rwnd_size >> wscale;  
		// MTP TODO: fix this
    	uint16_t advertised_window = (uint16_t)MIN(window32, TCP_MAX_WINDOW);
        bp->hdr.window = htons(advertised_window);

        // Payload
        // MTP TODO: fix snbuf
		uint8_t *data = sndvar->sndbuf->head + MTP_SEQ_SUB(ctx->send_una,
														   sndvar->sndbuf->head_seq,
														   sndvar->sndbuf->head_seq);
        bp->payload.data = data;
        bp->payload.len = bytes_to_send;
        bp->payload.needs_segmentation = FALSE;

        AddtoGenList(mtcp, cur_stream, cur_ts);

		// printf("dup ack prepared bp:\n");
		// print_MTP_bp(bp);
		// printf("dup ack head ptr: %p, head seq: %d, len: %d, snd wnd: %d\n", sndvar->sndbuf->head, 
		// 		sndvar->sndbuf->head_seq, sndvar->sndbuf->len, sndvar->snd_wnd);
		
		// printf("ack_net_ep before releasing lock\n");
		SBUF_UNLOCK(&sndvar->write_lock);
		// printf("ack_net_ep after releasing lock\n");
		return;
	}

	// Continue sending if window is available and there's remaining data in sending buffer
	uint32_t window_avail = 0;
	uint32_t window_end = ev_ack_seq + effective_window;
	if (MTP_SEQ_GT(window_end, ctx->send_next, ctx->send_una)) 
		window_avail = MTP_SEQ_SUB(window_end, ctx->send_next,
								   ctx->send_una);

	if (window_avail == 0)
		bytes_to_send = 0;
	else {
        if (data_rest < window_avail) bytes_to_send = data_rest;
        else bytes_to_send = window_avail;
    }

	// MTP TODO: check bytes to send is not zero
	// printf("ack_net_ep: bytes to send: %d\n", bytes_to_send);

	if (bytes_to_send > 0) {

		mtp_bp* bp = GetFreeBP(cur_stream);

		// printf("got bp\n");
		// printf("index: %u\n", cur_stream->sndvar->mtp_bps_tail);
		
		memset(&(bp->hdr), 0, sizeof(struct mtp_bp_hdr) + sizeof(struct mtp_bp_options));

		bp->hdr.source = cur_stream->mtp->local_port;
		bp->hdr.dest = cur_stream->mtp->remote_port;
		bp->hdr.seq = htonl(ctx->send_next);
		// printf("Seq ack_ep: %u\n", ntohl(bp->hdr.seq));
		bp->hdr.ack_seq = htonl(ctx->recv_next);

		bp->hdr.syn = FALSE;
		bp->hdr.ack = TRUE;

		// options to calculate data offset
	
		// MTP TODO: SACK? 
	#if TCP_OPT_SACK_ENABLED
		printf("ERROR:SACK Not supported in MTP TCP\n");
	#endif

		MTP_set_opt_nop(&(bp->opts.nop1));
		MTP_set_opt_nop(&(bp->opts.nop2));

		// MTP TODO: Timestamp
		MTP_set_opt_timestamp(&(bp->opts.timestamp),
								htonl(cur_ts),
								htonl(ctx->ts_recent));
		
	
		// MTP TODO: would the MTP program do the length 
		//           calculation itself?
		uint16_t optlen = MTP_CalculateOptionLength(bp);
		bp->hdr.doff = (MTP_HEADER_LEN + optlen) >> 2;

		// MTP TODO: wscale on local
		uint32_t window32 = cur_stream->mtp->rwnd_size >> cur_stream->mtp->wscale;
		uint16_t advertised_window = MIN(window32, TCP_MAX_WINDOW);
		bp->hdr.window = htons(advertised_window);

		// Payload
		// MTP TODO: fix snbuf
		uint8_t *data = sndvar->sndbuf->head + MTP_SEQ_SUB(ctx->send_next,
														sndvar->sndbuf->head_seq,
														sndvar->sndbuf->head_seq);
		bp->payload.data = data;
		bp->payload.len = bytes_to_send;
		bp->payload.needs_segmentation = TRUE;
		bp->payload.seg_size = ctx->eff_SMSS;
		bp->payload.seg_rule_group_id = 1; 

		AddtoGenList(mtcp, cur_stream, cur_ts);	

		// printf("prepared bp:\n");
		// print_MTP_bp(bp);
		// printf("head ptr: %p, head seq: %d, len: %d, snd_wnd: %d\n", sndvar->sndbuf->head, 
		// 		sndvar->sndbuf->head_seq, sndvar->sndbuf->len, sndvar->snd_wnd);

		ctx->send_next = ctx->send_next + bytes_to_send;
		// printf("ack_ep send next: %u\n", ctx->send_next);
	}

	// Remove acked sequence from sending buffer
	// This step is kinda target dependent (depending on the implementation of sending buffer)
	uint32_t rmlen = MTP_SEQ_SUB(ev_ack_seq, ctx->send_una, ctx->send_una);
	// printf("ack_net_ep: rmlen: %u, send_una: %u, ev_ack_seq: %u\n", 
	// 		rmlen, ctx->send_una, ev_ack_seq);
	if(rmlen > 0) {
		// printf("Removing %d bytes\n", rmlen);
		//uint32_t offset = MTP_SEQ_SUB(ctx->send_una, ctx->init_seq, ctx->init_seq);
		uint32_t offset = ctx->send_una;
		TxDataFlush(mtcp, cur_stream, offset, rmlen);
		// printf("head ptr: %p, head seq: %d, len: %d, snd_wnd: %d\n", sndvar->sndbuf->head, 
			// sndvar->sndbuf->head_seq, sndvar->sndbuf->len, sndvar->snd_wnd);
		ctx->send_una = ev_ack_seq;
		ctx->num_rtx = 0;
	}

	// MTP TODO: match the mtp file in creating right "event" on timeout
	TimerRestart(mtcp, cur_stream, cur_ts);
	// printf("ack_net_ep before releasing lock\n");
	SBUF_UNLOCK(&sndvar->write_lock);
	// printf("ack_net_ep after releasing lock\n");
}

static inline void fin_ack_ep(mtcp_manager_t mtcp, uint32_t cur_ts, 
		uint32_t ev_ack_seq, tcp_stream *cur_stream, scratchpad *scratch)
{
	struct mtp_ctx *ctx = cur_stream->mtp;
	if (ctx->state != MTP_TCP_FIN_WAIT_1_ST) return;
	
	if (ctx->fin_sent && 
		ev_ack_seq == ctx->final_seq + 1) {
		ctx->send_una = ev_ack_seq;
		if (MTP_SEQ_GT(ev_ack_seq, ctx->send_next, ctx->send_una)) {
			TRACE_DBG("Stream %d: update snd_nxt to %u\n", 
					cur_stream->id, ev_ack_seq);
			ctx->send_next = ev_ack_seq;
		}
		
		ctx->num_rtx = 0;
		TimerCancel(mtcp, cur_stream);
		ctx->state = MTP_TCP_FIN_WAIT_2_ST;
		TRACE_STATE("Stream %d: TCP_ST_FIN_WAIT_2\n", 
					cur_stream->id);
	}
}

static inline void data_net_ep(mtcp_manager_t mtcp, uint32_t cur_ts, uint32_t ev_seq, uint8_t *ev_payload,
    int ev_payloadlen, tcp_stream* cur_stream)
{
	struct mtp_ctx *ctx = cur_stream->mtp;
    struct tcp_recv_vars *rcvvar = cur_stream->rcvvar;
    uint32_t last_rcvd_seq = ev_seq + ev_payloadlen;

	// MTP TODO?: new ordered data

	printf("data_net_ep: ev_seq: %u, ev_payloadlen: %d, last_rcvd_seq: %u\n", 
			ev_seq, ev_payloadlen, last_rcvd_seq);
	// if seq and segment length is lower than rcv_nxt or exceeds buffer, ignore and send ack
	if (MTP_SEQ_LT(last_rcvd_seq, ctx->recv_next, ctx->recv_init_seq) ||
		MTP_SEQ_GT(last_rcvd_seq, ctx->recv_next + ctx->rwnd_size, ctx->recv_init_seq)) {
		return;
	}

	if (!rcvvar->rcvbuf) {
		rcvvar->rcvbuf = RBInit(mtcp->rbm_rcv, ctx->recv_init_seq);
		ctx->meta_rwnd = RBInit(mtcp->rbm_rcv, ctx->recv_init_seq);
		if (!rcvvar->rcvbuf || !ctx->meta_rwnd) {
			printf("Stream %d: Failed to allocate receive buffer.\n", 
					cur_stream->id);
			cur_stream->state = TCP_ST_CLOSED;
			cur_stream->close_reason = TCP_NO_MEM;
			RaiseErrorEvent(mtcp, cur_stream);

			return;
		}
	}

	printf("Grabbing lock in data_net_ep\n");
	if (SBUF_LOCK(&rcvvar->read_lock)) {
		if (errno == EDEADLK) perror("ProcessTCPPayload: read_lock blocked\n");
		assert(0);
	}

	MtpWndPut(mtcp->rbm_rcv, ctx->meta_rwnd, ev_payload, ev_payloadlen, ev_seq);
	MtpWndSlide(mtcp->rbm_rcv, ctx->meta_rwnd, AT_MTCP);
	ctx->recv_next = ctx->meta_rwnd->head_seq;

    RBPut(mtcp->rbm_rcv, rcvvar->rcvbuf, ev_payload, ev_payloadlen, ev_seq);

	SBUF_UNLOCK(&rcvvar->read_lock);

	if (ctx->state == MTP_TCP_ESTABLISHED_ST) {
		// "add_data_seg" instruction
		printf("data_net_ep: raising read event\n");
		RaiseReadEvent(mtcp, cur_stream);
	}
}

inline void send_ack_ep(mtcp_manager_t mtcp, uint32_t cur_ts, tcp_stream *cur_stream)
{
	struct mtp_ctx *ctx = cur_stream->mtp;
    struct tcp_recv_vars *rcvvar = cur_stream->rcvvar;

	ctx->rwnd_size = rcvvar->rcvbuf->size - MTP_SEQ_SUB(ctx->last_flushed, 
														ctx->recv_next, 
														ctx->recv_next);

	mtp_bp* bp = GetFreeBP(cur_stream);

	// printf("got bp\n");
	// printf("index: %u\n", cur_stream->sndvar->mtp_bps_tail);
	
	memset(&(bp->hdr), 0, sizeof(struct mtp_bp_hdr) + sizeof(struct mtp_bp_options));

	bp->hdr.source = cur_stream->mtp->local_port;
	bp->hdr.dest = cur_stream->mtp->remote_port;
	bp->hdr.seq = htonl(ctx->send_next);
	// printf("Seq ack_ep: %u\n", ntohl(bp->hdr.seq));
	bp->hdr.ack_seq = htonl(ctx->recv_next);

	bp->hdr.syn = FALSE;
	bp->hdr.ack = TRUE;

	// options to calculate data offset

	// MTP TODO: SACK? 
#if TCP_OPT_SACK_ENABLED
	printf("ERROR:SACK Not supported in MTP TCP\n");
#endif

	MTP_set_opt_nop(&(bp->opts.nop1));
	MTP_set_opt_nop(&(bp->opts.nop2));

	// MTP TODO: Timestamp
	MTP_set_opt_timestamp(&(bp->opts.timestamp),
							htonl(cur_ts),
							htonl(ctx->ts_recent));
	

	// MTP TODO: would the MTP program do the length 
	//           calculation itself?
	uint16_t optlen = MTP_CalculateOptionLength(bp);
	bp->hdr.doff = (MTP_HEADER_LEN + optlen) >> 2;

	// MTP TODO: wscale on local
	uint32_t window32 = ctx->rwnd_size >> ctx->wscale;
	uint16_t advertised_window = MIN(window32, TCP_MAX_WINDOW);
	bp->hdr.window = htons(advertised_window);

	// Payload
	// MTP TODO: fix snbuf
	bp->payload.data = NULL;
	bp->payload.len = 0;
	bp->payload.needs_segmentation = FALSE;

	AddtoGenList(mtcp, cur_stream, cur_ts);
    
}

static inline int listen_ep(mtcp_manager_t mtcp, int sockid, int backlog) 
{
	return CreateListenCtx(mtcp, sockid, backlog);
}

static inline struct accept_res* accept_ep(mctx_t mctx, mtcp_manager_t mtcp,
	struct sockaddr *addr, socklen_t *addrlen, bool non_block, struct mtp_listen_ctx *ctx) 
{
	// Wait until a client request to connect
	pthread_mutex_lock(&ctx->accept_lock);
	if (TAILQ_EMPTY(&ctx->pending)) {
		if (non_block) {
			printf("accept_ep: non-blocking mode, no pending connections\n");
			pthread_mutex_unlock(&ctx->accept_lock);
			printf("accept_ep: errno set to EAGAIN\n");
			errno = EAGAIN;
			printf("accept_ep: returning NULL\n");
			return NULL;
		}
		else{
			printf("accept_ep: blocking mode, waiting for connections\n");
			pthread_cond_wait(&ctx->accept_cond, &ctx->accept_lock);// check lock
			if (mtcp->ctx->done || mtcp->ctx->exit) {
				pthread_mutex_unlock(&ctx->accept_lock);
				errno = EINTR;
				return NULL;
			}
		}
	}

	printf("accept_ep: pending connections available, proceeding\n");
	struct accept_res *res = TAILQ_FIRST(&ctx->pending);
	TAILQ_REMOVE(&ctx->pending, res, link);
	ctx->pending_len--;
	pthread_mutex_unlock(&ctx->accept_lock);

	if (ctx->state == 0)
		ctx->state = 1;

	// Return res, let target (api) do the following socket allocation
	return res;
}

static inline void syn_ep(mtcp_manager_t mtcp, uint32_t cur_ts,
	uint32_t ev_remote_ip, uint16_t ev_remote_port, uint32_t ev_init_seq, uint16_t ev_rwnd_size,
    bool ev_sack_permit, bool ev_mss_valid, uint16_t ev_mss, bool ev_wscale_valid, uint8_t ev_wscale,
	struct tcp_opt_timestamp *ev_ts,
	struct mtp_listen_ctx *ctx)
{
	if (ctx->state != MTP_TCP_LISTEN_ST) return;
    
    // MTP TODO: do rand init seq
    // uint32_t init_seq = rand_r(&next_seed) % TCP_MAX_SEQ;
    uint32_t init_seq = 0;

    uint8_t wscale = 0;
    if (ev_wscale_valid) wscale = ev_wscale;

    uint16_t mss = 1460;
    if (ev_mss_valid) mss = ev_mss;
	// MTP new_ctx instruction
	tcp_stream *cur_stream = CreateCtx(mtcp, cur_ts, 
                                      ev_remote_ip, ctx->local_ip, 
                                      ev_remote_port, ctx->local_port,
                                      ev_sack_permit, mss, 
                                      init_seq, init_seq, init_seq + 1,
                                      ev_init_seq, ev_init_seq + 1, ev_init_seq,
                                      ev_rwnd_size, wscale,
                                      MTP_TCP_SYNACK_SENT_ST);
									  printf("local_ip: %u\n",
											ctx->local_ip);
	if (cur_stream == NULL) return;

	cur_stream->sndvar->sndbuf = SBInit(mtcp->rbm_snd, cur_stream->mtp->init_seq + 1);
	if (!cur_stream->sndvar->sndbuf) {
		cur_stream->close_reason = TCP_NO_MEM;
		/* notification may not required due to -1 return */
		errno = ENOMEM;
		return;
	}

	// Add stream to the listen context
	// Note: since mTCP's accept_res struct includes flow context, we insert
	//		new accept_res after context creation
	pthread_mutex_lock(&ctx->accept_lock);
	if (ctx->pending_len < ctx->pending_cap) {
		struct accept_res *acc = malloc(sizeof(*acc));
		acc->stream = cur_stream;
		TAILQ_INSERT_TAIL(&ctx->pending, acc, link);
		ctx->pending_len++;
	} else {
		// Error handling
		cur_stream->state = TCP_ST_CLOSED;
		cur_stream->close_reason = TCP_NOT_ACCEPTED;
		pthread_mutex_unlock(&ctx->accept_lock);
		return;
	}
	pthread_mutex_unlock(&ctx->accept_lock);

	// MTP pkt gen
	/*uint32_t window32 = cur_stream->rcvvar->rcv_wnd;
	uint16_t advertised_window = MIN(window32, TCP_MAX_WINDOW);

	SendMTPPacket(mtcp, cur_stream, cur_ts,
		TCP_FLAG_SYN | TCP_FLAG_ACK, 
		cur_stream->sndvar->iss, //seq
		init_seq + 1, //ack
		advertised_window, //window
		NULL, 0);
    */
    // MTP TODO: check that size + options is not more than MSS
   
    mtp_bp* bp = GetFreeBP(cur_stream);

	// printf("got bp\n");
	// printf("index: %u\n", cur_stream->sndvar->mtp_bps_tail);
    
    memset(&(bp->hdr), 0, sizeof(struct mtp_bp_hdr) + sizeof(struct mtp_bp_options));

	bp->hdr.source = cur_stream->mtp->local_port;
	bp->hdr.dest = cur_stream->mtp->remote_port;
    bp->hdr.seq = htonl(cur_stream->mtp->init_seq);
	// printf("Seq: %u\n", ntohl(bp->hdr.seq));
    bp->hdr.ack_seq = htonl(ev_init_seq + 1);

    bp->hdr.syn = TRUE;
    bp->hdr.ack = TRUE;

    // options to calculate data offset
    // MSS
    MTP_set_opt_mss(&(bp->opts.mss), cur_stream->mtp->SMSS);
   
    // MTP TODO: SACK? 
#if TCP_OPT_SACK_ENABLED
    printf("ERROR:SACK Not supported in MTP TCP\n");
#endif

    MTP_set_opt_nop(&(bp->opts.nop1));
    MTP_set_opt_nop(&(bp->opts.nop2));

    // MTP TODO: Timestamp
	uint32_t ts_value2 = 0;
	if (ev_ts->valid){
		ts_value2 = ev_ts->value1;
	}
    MTP_set_opt_timestamp(&(bp->opts.timestamp),
                            htonl(cur_ts),
                            htonl(ts_value2));
    
    // MTP TODO: Window scale
    MTP_set_opt_nop(&(bp->opts.nop3));
    MTP_set_opt_wscale(&(bp->opts.wscale), cur_stream->mtp->wscale);
   
    // MTP TODO: would the MTP program do the length 
    //           calculation itself?
    uint16_t optlen = MTP_CalculateOptionLength(bp);
    bp->hdr.doff = (MTP_HEADER_LEN + optlen) >> 2;

    uint32_t window32 = cur_stream->mtp->rwnd_size >> cur_stream->mtp->wscale;
	uint16_t advertised_window = MIN(window32, TCP_MAX_WINDOW);
	bp->hdr.window = htons(advertised_window);

    // Payload
    bp->payload.data = NULL;
    bp->payload.len = 0;
    bp->payload.needs_segmentation = FALSE;

    AddtoGenList(mtcp, cur_stream, cur_ts);
}

void synack_ep(mtcp_manager_t mtcp, uint32_t cur_ts, 
				uint32_t ev_init_seq, uint32_t ev_ack_seq, 
				uint16_t ev_rwnd_size, bool ev_sack_permit, 
				bool ev_mss_valid, uint16_t ev_mss, 
				bool ev_wscale_valid, uint8_t ev_wscale,
				struct tcp_opt_timestamp* ev_ts, 
				tcp_stream* cur_stream)
{
	struct mtp_ctx *ctx = cur_stream->mtp;

	if (ctx->state != MTP_TCP_SYN_SENT_ST) {
		printf("MtpSyNAckChain: Invalid state %d for SYN-ACK\n", ctx->state);
		return;
	}

	
	ctx->state = MTP_TCP_ESTABLISHED_ST; //ESTABLISHED_ST

	// receiver related variables
    ctx->recv_init_seq = ev_init_seq;
    ctx->recv_next = ev_init_seq + 1;
	ctx->last_flushed = ev_init_seq;

	// sender related variables
    ctx->last_rwnd_remote = ev_rwnd_size;
	ctx->send_una = ev_ack_seq;
	ctx->send_next = ev_ack_seq;
	ctx->lwu_seq = ev_init_seq - 1;
	ctx->last_ack = ev_ack_seq;

	// options
	if (ev_wscale_valid) ctx->wscale_remote = ev_wscale;
	if (ev_mss_valid) ctx->SMSS = ev_mss;
	ctx->sack_permit_remote = ev_sack_permit;
	ctx->ts_recent = ev_ts->value1;
	ctx->ts_lastack_rcvd = ev_ts->value2;
	// MTP TODO: integrate with MTP
	cur_stream->rcvvar->ts_lastack_rcvd = ev_ts->value2;
	ctx->ts_last_ts_upd = cur_ts;

	// Other sender size variables
	if (ctx->cwnd_size == 1) ctx->cwnd_size = 2 * ctx->SMSS;
	else ctx->cwnd_size = ctx->SMSS;
	ctx->ssthresh = ctx->SMSS * 10;

	mtp_bp* bp = GetFreeBP(cur_stream);

	// printf("got bp\n");
	// printf("index: %u\n", cur_stream->sndvar->mtp_bps_tail);
	
	memset(&(bp->hdr), 0, sizeof(struct mtp_bp_hdr) + sizeof(struct mtp_bp_options));

	bp->hdr.source = cur_stream->mtp->local_port;
	bp->hdr.dest = cur_stream->mtp->remote_port;
	bp->hdr.seq = htonl(ctx->send_next);
	// printf("Seq ack_ep: %u\n", ntohl(bp->hdr.seq));
	bp->hdr.ack_seq = htonl(ctx->recv_next);

	bp->hdr.syn = FALSE;
	bp->hdr.ack = TRUE;

	// options to calculate data offset

	// MTP TODO: SACK? 
#if TCP_OPT_SACK_ENABLED
	printf("ERROR:SACK Not supported in MTP TCP\n");
#endif

	MTP_set_opt_nop(&(bp->opts.nop1));
	MTP_set_opt_nop(&(bp->opts.nop2));

	// MTP TODO: Timestamp
	MTP_set_opt_timestamp(&(bp->opts.timestamp),
							htonl(cur_ts),
							htonl(ctx->ts_recent));
	

	// MTP TODO: would the MTP program do the length 
	//           calculation itself?
	uint16_t optlen = MTP_CalculateOptionLength(bp);
	bp->hdr.doff = (MTP_HEADER_LEN + optlen) >> 2;

	// MTP TODO: wscale on local
	uint32_t window32 = cur_stream->mtp->rwnd_size >> cur_stream->mtp->wscale;
	uint16_t advertised_window = MIN(window32, TCP_MAX_WINDOW);
	bp->hdr.window = htons(advertised_window);

	// Payload
	// MTP TODO: fix snbuf
	bp->payload.data = NULL;
	bp->payload.len = 0;
	bp->payload.needs_segmentation = FALSE;

	AddtoGenList(mtcp, cur_stream, cur_ts);
	
	// MTP TODO: integrate into MTP
	RaiseWriteEvent(mtcp, cur_stream);
}

void timeout_ep(mtcp_manager_t mtcp, uint32_t cur_ts, tcp_stream* cur_stream){
	struct mtp_ctx *ctx = cur_stream->mtp;
	printf("Stream %d Timeout. cwnd: %u, ssthresh: %u\n", 
			cur_stream->id, ctx->cwnd_size, ctx->ssthresh);
	printf("Stream %d Timeout. rto: %u, tx_rto:%u, cur_ts: %u\n", 
			cur_stream->id, cur_stream->sndvar->rto, 
			cur_stream->sndvar->ts_rto, cur_ts);			

	/* count number of retransmissions */
	if (ctx->num_rtx < MTP_TCP_MAX_RTX) {
		ctx->num_rtx = ctx->num_rtx + 1;
	} else {
		/* if it exceeds the threshold, destroy and notify to application */
		printf("Stream %d: Exceed MAX_RTX\n", cur_stream->id);
		
	}
	if (ctx->num_rtx > ctx->max_num_rtx) {
		ctx->max_num_rtx = ctx->num_rtx;
	}
	
	uint8_t backoff;
	/* update rto timestamp */
	if (ctx->state >= MTP_TCP_ESTABLISHED_ST) {
		backoff = MIN(ctx->num_rtx, MTP_TCP_MAX_BACKOFF);

		uint32_t rto_prev;
		rto_prev = cur_stream->sndvar->rto;
		cur_stream->sndvar->rto = ((cur_stream->rcvvar->srtt >> 3) + 
				cur_stream->rcvvar->rttvar) << backoff;
		if (cur_stream->sndvar->rto <= 0) {
			printf("Stream %d current rto: %u, prev: %u, state: %s\n", 
					cur_stream->id, cur_stream->sndvar->rto, rto_prev, 
					TCPStateToString(cur_stream));
			cur_stream->sndvar->rto = rto_prev;
		}
	} else if (ctx->state >= MTP_TCP_SYN_SENT_ST) {
		/* if there is no rtt measured, update rto based on the previous one */
		if (ctx->num_rtx < MTP_TCP_MAX_BACKOFF) {
			cur_stream->sndvar->rto <<= 1;
		}
	}
	//cur_stream->sndvar->ts_rto = cur_ts + cur_stream->sndvar->rto;

	/* reduce congestion window and ssthresh */
	ctx->ssthresh = MIN(ctx->cwnd_size, ctx->last_rwnd_remote) / 2;
	if (ctx->ssthresh < (2 * ctx->SMSS)) {
		ctx->ssthresh = ctx->SMSS * 2;
	}
	ctx->cwnd_size = ctx->SMSS;
	
	/* Retransmission */
	// MTP TODO: add cases for other states
	
	if (ctx->state == MTP_TCP_ESTABLISHED_ST) {
		/* retransmit data at ESTABLISHED state */
		
		struct tcp_send_vars *sndvar = cur_stream->sndvar;

		SBUF_LOCK(&sndvar->write_lock);
        // MTP TODO: check that size + options is not more than MSS
        uint32_t data_rest =  sndvar->sndbuf->len - 
					      MTP_SEQ_SUB(ctx->send_una, sndvar->sndbuf->head_seq,
									  sndvar->sndbuf->head_seq);

		uint32_t effective_window = ctx->cwnd_size;
		if (ctx->last_rwnd_remote < effective_window){
			effective_window = ctx->last_rwnd_remote;
		}
		
		uint32_t bytes_to_send = effective_window;
		if (data_rest < effective_window) bytes_to_send = data_rest;
		
		// MTP TODO: check bytes to send is not zero
		// printf("ack_net_ep: bytes to send: %d\n", bytes_to_send);

		assert(bytes_to_send > 0);

		mtp_bp* bp = GetFreeBP(cur_stream);

		// printf("got bp\n");
		// printf("index: %u\n", cur_stream->sndvar->mtp_bps_tail);
		
		memset(&(bp->hdr), 0, sizeof(struct mtp_bp_hdr) + sizeof(struct mtp_bp_options));

		bp->hdr.source = cur_stream->mtp->local_port;
		bp->hdr.dest = cur_stream->mtp->remote_port;
		bp->hdr.seq = htonl(ctx->send_una);
		// printf("Seq ack_ep: %u\n", ntohl(bp->hdr.seq));
		bp->hdr.ack_seq = htonl(ctx->recv_next);

		bp->hdr.syn = FALSE;
		bp->hdr.ack = TRUE;

		// options to calculate data offset
	
		// MTP TODO: SACK? 
	#if TCP_OPT_SACK_ENABLED
		printf("ERROR:SACK Not supported in MTP TCP\n");
	#endif

		MTP_set_opt_nop(&(bp->opts.nop1));
		MTP_set_opt_nop(&(bp->opts.nop2));

		// MTP TODO: Timestamp
		MTP_set_opt_timestamp(&(bp->opts.timestamp),
								htonl(cur_ts),
								htonl(ctx->ts_recent));
		
	
		// MTP TODO: would the MTP program do the length 
		//           calculation itself?
		uint16_t optlen = MTP_CalculateOptionLength(bp);
		bp->hdr.doff = (MTP_HEADER_LEN + optlen) >> 2;

		// MTP TODO: wscale on local
		uint32_t window32 = cur_stream->mtp->rwnd_size >> cur_stream->mtp->wscale;
		uint16_t advertised_window = MIN(window32, TCP_MAX_WINDOW);
		bp->hdr.window = htons(advertised_window);

		// Payload
		// MTP TODO: fix snbuf
		uint8_t *data = sndvar->sndbuf->head + MTP_SEQ_SUB(ctx->send_next,
														sndvar->sndbuf->head_seq,
														sndvar->sndbuf->head_seq);
		bp->payload.data = data;
		bp->payload.len = bytes_to_send;
		bp->payload.needs_segmentation = TRUE;
		bp->payload.seg_size = ctx->eff_SMSS;
		bp->payload.seg_rule_group_id = 1; 

		AddtoGenList(mtcp, cur_stream, cur_ts);	
		
			
		// printf("ack_net_ep before releasing lock\n");
		TimerRestart(mtcp, cur_stream, cur_ts);
		
		SBUF_UNLOCK(&sndvar->write_lock);
		// printf("ack_net_ep after releasing lock\n");
	}
}

/***********************************************
 MTP Event Processor Chains
 
 EP chinas are globally exposed
 They implement parts for dispatcher in MTP code
 ***********************************************/
void MtpSendChain(mtcp_manager_t mtcp, uint32_t cur_ts, tcp_stream *cur_stream)
{
	// printf("Calling send chain\n");
    send_ep(mtcp, cur_ts, cur_stream);
}

int MtpReceiveChain(mtcp_manager_t mtcp, socket_map_t socket, 
					char *ev_buf, int ev_data_size, 
					tcp_stream *cur_stream)
{
	return receive_ep(mtcp, socket, ev_buf, ev_data_size, cur_stream);
}

void MtpAckChain(mtcp_manager_t mtcp, uint32_t cur_ts, uint32_t ack_seq, 
    uint32_t window, uint32_t seq, struct tcp_opt_timestamp* ev_ts, tcp_stream* cur_stream)
{
    /*
    struct tcp_send_vars *sndvar = cur_stream->sndvar;

    if (cur_stream->state == TCP_ST_SYN_RCVD){
		// check if we're processing an acknowledgement of a SYN-ACK
		if (ack_seq != sndvar->iss + 1) {
			CTRACE_ERROR("Stream %d (TCP_ST_SYN_RCVD): "
					"weird ack_seq: %u, iss: %u\n", 
					cur_stream->id, ack_seq, sndvar->iss);
			return;
		}

		TimerCancel(mtcp, cur_stream);
	
		uint32_t prior_cwnd = sndvar->cwnd;
		sndvar->snd_una++;
		cur_stream->snd_nxt = ack_seq;
		sndvar->cwnd = ((prior_cwnd == 1) ? (sndvar->mss * TCP_INIT_CWND): sndvar->mss);
		cur_stream->state = TCP_ST_ESTABLISHED;

		// Raise an event to the listening socket
		struct mtp_listen_ctx *listen_ctx = 
			(struct mtp_listen_ctx *)ListenerHTSearch(mtcp->listeners, &cur_stream->sport);
		if (listen_ctx->socket && (listen_ctx->socket->epoll & MTCP_EPOLLIN)) {
			AddEpollEvent(mtcp->ep, MTCP_EVENT_QUEUE, listen_ctx->socket, MTCP_EPOLLIN);
		}
    } else if(cur_stream->state == TCP_ST_ESTABLISHED) {
    */
    scratchpad scratch;
	timestamp_ep(mtcp, cur_ts, ev_ts, cur_stream, &scratch);
    conn_ack_ep(mtcp, cur_ts, ack_seq, seq, cur_stream, &scratch);
	fin_ack_ep();
    rto_ep(mtcp, cur_ts, ack_seq, cur_stream, &scratch);
    fast_retr_rec_ep(mtcp, cur_ts, ack_seq, cur_stream, &scratch);
    slows_congc_ep(mtcp, cur_ts, ack_seq, cur_stream, &scratch);
    ack_net_ep(mtcp, cur_ts, ack_seq, window, seq, cur_stream, &scratch);
}

void MtpDataChain(mtcp_manager_t mtcp, uint32_t cur_ts, uint32_t seq, uint8_t *payload, 
	int payloadlen, tcp_stream *cur_stream)
{
	data_net_ep(mtcp, cur_ts, seq, payload, payloadlen, cur_stream);
    send_ack_ep(mtcp, cur_ts, cur_stream);
}

int MtpListenChain(mtcp_manager_t mtcp, int sockid, int backlog)
{
	return listen_ep(mtcp, sockid, backlog);
}

struct accept_res* MtpAcceptChain(mctx_t mctx, mtcp_manager_t mtcp, struct sockaddr *addr, 
	socklen_t *addrlen, bool non_block, struct mtp_listen_ctx *ctx) 
{
	return accept_ep(mctx, mtcp, addr, addrlen, non_block, ctx);
}


tcp_stream* MtpConnectChainPart1(mtcp_manager_t mtcp, uint32_t cur_ts,
					 uint32_t ev_local_ip, uint32_t ev_remote_ip, 
					 uint16_t ev_local_port, uint16_t ev_remote_port){
	
	// MTP TODO: do rand init seq
	// uint32_t init_seq = rand_r(&next_seed) % TCP_MAX_SEQ;
	uint32_t init_seq = 0;	

	tcp_stream *cur_stream = CreateCtx(mtcp, cur_ts, 
                                      ev_remote_ip, ev_local_ip, 
                                      ev_remote_port, ev_local_port,
                                      false, 1460, 
                                      init_seq, init_seq, init_seq + 1,
                                      0, 0, 0, 0, 0,
                                      MTP_TCP_SYN_SENT_ST);
	printf("Created stream with saddr: %u, daddr: %u, sport: %u, dport: %u\n",
			cur_stream->saddr, cur_stream->daddr,
			cur_stream->sport, cur_stream->dport);

	cur_stream->sndvar->sndbuf = SBInit(mtcp->rbm_snd, cur_stream->mtp->init_seq + 1);
	if (!cur_stream->sndvar->sndbuf) {
		cur_stream->close_reason = TCP_NO_MEM;
		/* notification may not required due to -1 return */
		errno = ENOMEM;
		return NULL;
	}
	return cur_stream;
}
	
void MtpConnectChainPart2(mtcp_manager_t mtcp, uint32_t cur_ts,
					 uint32_t ev_local_ip, uint32_t ev_remote_ip, 
					 uint16_t ev_local_port, uint16_t ev_remote_port, 
					 tcp_stream *cur_stream){	
	
	mtp_bp* bp = GetFreeBP(cur_stream);

	// printf("got bp\n");
	// printf("index: %u\n", cur_stream->sndvar->mtp_bps_tail);
    
    memset(&(bp->hdr), 0, sizeof(struct mtp_bp_hdr) + sizeof(struct mtp_bp_options));

	struct mtp_ctx *ctx = cur_stream->mtp;
	bp->hdr.source = ctx->local_port;
	bp->hdr.dest = ctx->remote_port;
	// MTP TODO: technically, should be the variable in Part1
    bp->hdr.seq = htonl(ctx->init_seq);
    bp->hdr.syn = TRUE;
    bp->hdr.ack = FALSE;

    // options to calculate data offset
    // MSS
    MTP_set_opt_mss(&(bp->opts.mss), cur_stream->mtp->SMSS);
   
    // MTP TODO: SACK? 
#if TCP_OPT_SACK_ENABLED
    printf("ERROR:SACK Not supported in MTP TCP\n");
#endif

    MTP_set_opt_nop(&(bp->opts.nop1));
    MTP_set_opt_nop(&(bp->opts.nop2));

    // MTP TODO: Timestamp
    MTP_set_opt_timestamp(&(bp->opts.timestamp),
                            htonl(cur_ts),
                            htonl(ctx->ts_recent));
    
    // MTP TODO: Window scale
    MTP_set_opt_nop(&(bp->opts.nop3));
    MTP_set_opt_wscale(&(bp->opts.wscale), cur_stream->mtp->wscale);
   
    // MTP TODO: would the MTP program do the length 
    //           calculation itself?
    uint16_t optlen = MTP_CalculateOptionLength(bp);
    bp->hdr.doff = (MTP_HEADER_LEN + optlen) >> 2;

    uint32_t window32 = cur_stream->mtp->rwnd_size >> cur_stream->mtp->wscale;
	uint16_t advertised_window = MIN(window32, TCP_MAX_WINDOW);
	bp->hdr.window = htons(advertised_window);

    // Payload
    bp->payload.data = NULL;
    bp->payload.len = 0;
    bp->payload.needs_segmentation = FALSE;

    AddtoGenList(mtcp, cur_stream, cur_ts);
}

void MtpSynChain(mtcp_manager_t mtcp, uint32_t cur_ts,
	uint32_t remote_ip, uint16_t remote_port, uint32_t init_seq, uint16_t rwnd_size,
    bool sack_permit, bool mss_valid, uint16_t mss, bool wscale_valid, uint8_t wscale,
	struct tcp_opt_timestamp *ev_ts, struct mtp_listen_ctx *ctx) 
{
	syn_ep(mtcp, cur_ts, remote_ip, remote_port, init_seq, rwnd_size, 
           sack_permit, mss_valid, mss, wscale_valid, wscale, ev_ts, ctx);
}

void MtpSyNAckChain(mtcp_manager_t mtcp, uint32_t cur_ts, 
					uint32_t ev_init_seq, uint32_t ev_ack_seq, 
					uint16_t ev_rwnd_size, bool ev_sack_permit, 
					bool ev_mss_valid, uint16_t ev_mss, 
                    bool ev_wscale_valid, uint8_t ev_wscale,
					struct tcp_opt_timestamp* ev_ts, 
					tcp_stream* cur_stream){
	synack_ep(mtcp, cur_ts, ev_init_seq, ev_ack_seq,	
				ev_rwnd_size, ev_sack_permit, 
				ev_mss_valid, ev_mss, 
				ev_wscale_valid, ev_wscale,
				ev_ts, cur_stream);

}

void MtpTimeoutChain(mtcp_manager_t mtcp, uint32_t cur_ts, tcp_stream* cur_stream){
	timeout_ep(mtcp, cur_ts, cur_stream);
}

void MtpCloseChain(mtcp_manager_t mtcp, uint32_t cur_ts, tcp_stream* cur_stream){
	struct mtp_ctx *ctx = cur_stream->mtp;

	ctx->closed = TRUE;

	if (ctx->state == MTP_TCP_CLOSED_ST) {
		printf("Stream %d at TCP_ST_CLOSED. destroying the stream.\n", 
				cur_stream->id);
		DestroyCtx(mtcp, cur_stream, ctx->local_port);
		return;

	} else if (ctx->state == MTP_TCP_SYN_SENT_ST) {
#if 1
		DestroyCtx(mtcp, cur_stream, ctx->local_port);
#endif
		return;

	} else if (ctx->state != MTP_TCP_ESTABLISHED_ST && 
			ctx->state != MTP_TCP_CLOSE_WAIT_ST) {
		TRACE_API("Stream %d at bad state\n", 
				cur_stream->id);
		errno = EBADF;
		return;
	}

	struct tcp_send_vars *sndvar = cur_stream->sndvar;
	if (sndvar->sndbuf) {
		ctx->final_seq = sndvar->sndbuf->head_seq + sndvar->sndbuf->len;
	} else {
		ctx->final_seq = ctx->send_next;
	}

	if (CONFIG.tcp_timeout > 0)
		RemoveFromTimeoutList(mtcp, cur_stream);

	if (ctx->state == MTP_TCP_ESTABLISHED_ST) {
		ctx->state = MTP_TCP_FIN_WAIT_1_ST;
	} else if (ctx->state == MTP_TCP_CLOSE_WAIT_ST) {
		ctx->state = MTP_TCP_LAST_ACK_ST;
	}
	// SEND FIN
	ctx->fin_sent = TRUE;

	mtp_bp* bp = GetFreeBP(cur_stream);

	// printf("got bp\n");
	// printf("index: %u\n", cur_stream->sndvar->mtp_bps_tail);
	
	memset(&(bp->hdr), 0, sizeof(struct mtp_bp_hdr) + sizeof(struct mtp_bp_options));

	bp->hdr.source = cur_stream->mtp->local_port;
	bp->hdr.dest = cur_stream->mtp->remote_port;
	bp->hdr.seq = htonl(ctx->final_seq);
	// printf("Seq ack_ep: %u\n", ntohl(bp->hdr.seq));
	bp->hdr.ack_seq = htonl(ctx->recv_next);

	bp->hdr.syn = FALSE;
	bp->hdr.ack = TRUE;
	bp->hdr.fin = TRUE;

	// options to calculate data offset

	// MTP TODO: SACK? 
#if TCP_OPT_SACK_ENABLED
	printf("ERROR:SACK Not supported in MTP TCP\n");
#endif

	MTP_set_opt_nop(&(bp->opts.nop1));
	MTP_set_opt_nop(&(bp->opts.nop2));

	// MTP TODO: Timestamp
	MTP_set_opt_timestamp(&(bp->opts.timestamp),
							htonl(cur_ts),
							htonl(ctx->ts_recent));
	

	// MTP TODO: would the MTP program do the length 
	//           calculation itself?
	uint16_t optlen = MTP_CalculateOptionLength(bp);
	bp->hdr.doff = (MTP_HEADER_LEN + optlen) >> 2;

	// MTP TODO: wscale on local
	uint32_t window32 = ctx->rwnd_size >> ctx->wscale;
	uint16_t advertised_window = MIN(window32, TCP_MAX_WINDOW);
	bp->hdr.window = htons(advertised_window);

	// Payload
	// MTP TODO: fix snbuf
	bp->payload.data = NULL;
	bp->payload.len = 0;
	bp->payload.needs_segmentation = FALSE;

	AddtoGenList(mtcp, cur_stream, cur_ts);
}

void MtpFinChain(mtcp_manager_t mtcp, uint32_t cur_ts,
				 uint32_t ev_seq, uint32_t ev_payloadlen, 
				 tcp_stream* cur_stream){
	
    struct mtp_ctx *ctx = cur_stream->mtp;

	if (ctx->state == MTP_TCP_ESTABLISHED_ST){
		if (ev_seq + ev_payloadlen == ctx->recv_next) {
				ctx->state = MTP_TCP_CLOSE_WAIT_ST;
				TRACE_STATE("Stream %d: TCP_ST_CLOSE_WAIT\n", cur_stream->id);
				ctx->recv_next = ctx->recv_next + 1;
				/* notify FIN to application */
				RaiseReadEvent(mtcp, cur_stream);
		}

		mtp_bp* bp = GetFreeBP(cur_stream);

		// printf("got bp\n");
		// printf("index: %u\n", cur_stream->sndvar->mtp_bps_tail);
		
		memset(&(bp->hdr), 0, sizeof(struct mtp_bp_hdr) + sizeof(struct mtp_bp_options));

		bp->hdr.source = cur_stream->mtp->local_port;
		bp->hdr.dest = cur_stream->mtp->remote_port;
		bp->hdr.seq = htonl(ctx->send_next);
		// printf("Seq ack_ep: %u\n", ntohl(bp->hdr.seq));
		bp->hdr.ack_seq = htonl(ctx->recv_next);

		bp->hdr.syn = FALSE;
		bp->hdr.ack = TRUE;

		// options to calculate data offset

		// MTP TODO: SACK? 
	#if TCP_OPT_SACK_ENABLED
		printf("ERROR:SACK Not supported in MTP TCP\n");
	#endif

		MTP_set_opt_nop(&(bp->opts.nop1));
		MTP_set_opt_nop(&(bp->opts.nop2));

		// MTP TODO: Timestamp
		MTP_set_opt_timestamp(&(bp->opts.timestamp),
								htonl(cur_ts),
								htonl(ctx->ts_recent));
		

		// MTP TODO: would the MTP program do the length 
		//           calculation itself?
		uint16_t optlen = MTP_CalculateOptionLength(bp);
		bp->hdr.doff = (MTP_HEADER_LEN + optlen) >> 2;

		// MTP TODO: wscale on local
		uint32_t window32 = ctx->rwnd_size >> ctx->wscale;
		uint16_t advertised_window = MIN(window32, TCP_MAX_WINDOW);
		bp->hdr.window = htons(advertised_window);

		// Payload
		// MTP TODO: fix snbuf
		bp->payload.data = NULL;
		bp->payload.len = 0;
		bp->payload.needs_segmentation = FALSE;

		AddtoGenList(mtcp, cur_stream, cur_ts);

	}
}
